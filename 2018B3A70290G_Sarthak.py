# -*- coding: utf-8 -*-
"""2018B3A70290G_Sarthak.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tAyDBWEa2cb_kDcw2zfSVtCQbe4qMVF0
"""

# Commented out IPython magic to ensure Python compatibility.
from CNF_Creator import *
from ROLLNO_NAME import *
import time
import numpy as np
import random
import matplotlib.pyplot as plt
# %matplotlib inline

numVars = 50
maxTime = 45
populationSize = 30
mutationRate = 0.7

def calculateFitness(population, sentence):
  fitness = np.zeros(len(population))
  for i, model in enumerate(population):
    for clause in sentence:
      if ((model[abs(clause[0])-1]==0 and clause[0]<0) or (model[abs(clause[1])-1]==0 and clause[1]<0) or (model[abs(clause[2])-1]==0 and clause[2]<0)):
        fitness[i]+=1
      elif ((model[abs(clause[0])-1]>0 and clause[0]>0) or (model[abs(clause[1])-1]>0 and clause[1]>0) or (model[abs(clause[2])-1]>0 and clause[2]>0)):
        fitness[i]+=1
  return fitness

def calculateWeights(fitness):
  return fitness/np.sum(fitness)

def improvedselectParents(population, weights, sentence):
  tempParents = random.choices(population, weights = weights, k=5)
  tempFitness = calculateFitness(tempParents, sentence)
  parent1= tempParents[np.argmax(tempFitness)]
  tempParents = list(tempParents)
  tempParents.pop(np.argmax(tempFitness))
  tempFitness = calculateFitness(tempParents, sentence)
  parent2 = tempParents[np.argmax(tempFitness)]
  return parent1,parent2

def selectParents(population, weights, sentence):
  parent1, parent2=random.choices(population, weights = weights, k=2)
  return parent1,parent2

def eliteParents(population, sentence):
  tempParents = population
  tempFitness = calculateFitness(tempParents, sentence)
  parent1= tempParents[np.argmax(tempFitness)]
  tempParents = list(tempParents)
  tempParents.pop(np.argmax(tempFitness))
  tempFitness = calculateFitness(tempParents, sentence)
  parent2 = tempParents[np.argmax(tempFitness)]
  return parent1,parent2

def reproduce(parent1, parent2):
  crossover = random.randrange(len(parent1))
  combined = list(parent1[:crossover])+list(parent2[crossover:])
  combined = np.array(combined)
  return combined

def mutate(child):
  if random.random() < mutationRate:
    location = random.randrange(len(child))
    child[location] = 1-child[location]
  return child

def improvedalgorithm(sentence, population):
  maxFitness = len(sentence)
  fitness = calculateFitness(population, sentence)
  hist = [fitness.max()]
  startTime = time.time()
  while (fitness.max() < maxFitness) and time.time() < startTime + maxTime:
      weights = calculateWeights(fitness)
      nextPopulation = []
      for i in range(len(population)):
          parent1, parent2 = improvedselectParents(population, weights, sentence)
          child = reproduce(parent1, parent2)
          child = mutate(child)
          nextPopulation.append(child)
      population = nextPopulation
      fitness = calculateFitness(population, sentence)
      hist.append(fitness.max())
  return hist, population[np.argmax(fitness)], time.time() - startTime

def algorithm(sentence, population):
  maxFitness = len(sentence)
  fitness = calculateFitness(population, sentence)
  hist = [fitness.max()]
  startTime = time.time()
  while (fitness.max() < maxFitness) and time.time() < startTime + maxTime:
      weights = calculateWeights(fitness)
      nextPopulation = []
      for i in range(len(population)):
          parent1, parent2 = selectParents(population, weights, sentence)
          child = reproduce(parent1, parent2)
          child = mutate(child)
          nextPopulation.append(child)
      population = nextPopulation
      fitness = calculateFitness(population, sentence)
      hist.append(fitness.max())
  return hist, population[np.argmax(fitness)], time.time() - startTime

def execute(sentence):
  population = np.random.rand(populationSize, numVars)
  population = np.where(population > 0.5, 1, 0)
  return algorithm(sentence, population)
def improvedexecute(sentence):
  population = np.random.rand(populationSize, numVars)
  population = np.where(population > 0.5, 1, 0)
  return improvedalgorithm(sentence, population)

def loadCNF(name):
  with open(name) as csvfile:
      out_data = [[int(n) for n in line.split(',') if int(n)!=0] for line in csvfile.readlines() if line[0] not in ('c', 'p', '%', '0') and len(line.strip())!=0]
  return out_data

def solution():
  o1 = CNF_Creator(numVars)
  sentence = o1.ReadCNFfromCSVfile()
  # for i in range(5):
    # sentence = loadCNF("CNF"+str(i+1)+".csv")
    # hist, model, exec_time = execute(sentence)
  hist, model, exec_time = improvedexecute(sentence)
  fitness = hist[-1]/len(sentence)
  model = [model[i]*(i+1) for i in range(len(model))]
  print("Roll No : 2018A7PS0290G")
  print("Number of clauses in CSV file :", len(sentence))
  print("Best model :", model)
  # How to calculate % fitness if we do not know max val
  print("Fitness value of best model :", str(round(fitness*100,2))+"%")
  # print("Fitness value of best model :", fitness)
  print("Time taken :", round(exec_time,3), "seconds")
  
def plttr():
  ms = list(range(100, 300, 20))
  o1 = CNF_Creator(numVars)
  avgFitness = []
  avgTime = []
  for m in ms:
    avgFitness.append(0)
    avgTime.append(0)
    for i in range(10):
      sentence = o1.CreateRandomSentence(m)
      # hist, model, totalTime = execute(sentence)
      hist, model, totalTime = improvedexecute(sentence)
      avgFitness[-1] += hist[-1]*100
      avgTime[-1] += totalTime
    print(m)
    avgFitness[-1]/=(10*m)
    avgTime[-1]/=10
  print(avgFitness)
  print(avgTime)
  plt.plot(list(range(100, 300, 20)), avgTime)
  plt.xlabel("Number of clauses")
  plt.ylabel("Average Time (seconds)")
  plt.plot(list(range(100, 300, 20)), avgFitness)
  plt.xlabel("Number of clauses")
  plt.ylabel("Average Fitness (%) and Average Time (seconds)")
solution()